{"version":3,"sources":["src/marionette.approuter.js"],"names":["ObjectAPI","ClassOptions","AppRouter","Backbone","Router","extend","options","_setOptions","mergeOptions","apply","this","arguments","appRoutes","controller","_getController","processAppRoutes","on","_processOnRoute","route","methodName","_addAppRoute","routeName","routeArgs","_","isFunction","onRoute","routePath","invert","routeNames","keys","reverse","each","method","Error","bind","prototype","pick","MnObject","Marionette"],"mappings":";;;;;;;;;;;2fAwBMA,GACJ,gBACA,mBACA,cACA,eACA,YACA,aACA,gBAGIC,GACJ,YACA,cAGIC,EAAYC,EAASC,OAAOC,oBAAO,SAE3BC,QACLC,YAAYD,QAEZE,aAAaF,EAASL,KAElBG,OAAOK,MAAMC,KAAMC,eAEtBC,EAAYF,KAAKE,UACjBC,EAAaH,KAAKI,sBACnBC,iBAAiBF,EAAYD,QAC7BI,GAAG,QAASN,KAAKO,gBAAiBP,gBAZF,SAiB9BQ,EAAOC,OACRN,EAAaH,KAAKI,6BACnBM,aAAaP,EAAYK,EAAOC,GAC9BT,sBApB8B,SAyBvBW,EAAWC,MAErBC,EAAEC,WAAWd,KAAKe,SAAU,KAExBC,EAAYH,EAAEI,OAAOjB,KAAKE,WAAWS,QACtCI,QAAQJ,EAAWK,EAAWJ,sBA9BA,SAqCtBT,EAAYD,kBACtBA,SAAoBF,SAEnBkB,EAAaL,EAAEM,KAAKjB,GAAWkB,mBAEnCC,KAAKH,EAAY,SAAAV,KACZE,aAAaP,EAAYK,EAAON,EAAUM,MAG1CR,qBA9C8B,kBAkD9BA,KAAKG,yBAlDyB,SAqD1BA,EAAYK,EAAOC,OACxBa,EAASnB,EAAWM,OAErBa,QACG,IAAIC,MAAJ,WAAqBd,EAArB,0CAGHD,MAAMA,EAAOC,EAAYI,EAAEW,KAAKF,EAAQnB,cAIjDU,EAAElB,OAAOH,EAAUiC,UAAWZ,EAAEa,KAAKC,EAAAA,SAASF,UAAWnC,IAGzDsC,EAAWpC,UAAYA","file":"marionette.approuter.min.js","sourcesContent":["// App Router\n// ----------\n\n// Reduce the boilerplate code of handling route events\n// and then calling a single method on another object,\n// called a controller.\n// Have your routers configured to call the method on\n// your controller, directly.\n//\n// Configure an AppRouter with `appRoutes`.\n//\n// App routers can only take one `controller` object.\n// It is recommended that you divide your controller\n// objects in to smaller pieces of related functionality\n// and have multiple routers / controllers, instead of\n// just one giant router and controller.\n//\n// You can also add standard routes to an AppRouter.\n\nimport Backbone from 'backbone';\nimport _ from 'underscore';\nimport Marionette, { MnObject } from 'backbone.marionette';\n\n// API borrowed from Marionette.Object\nconst ObjectAPI = [\n  'triggerMethod',\n  'normalizeMethods',\n  '_setOptions',\n  'mergeOptions',\n  'getOption',\n  'bindEvents',\n  'unbindEvents'\n];\n\nconst ClassOptions = [\n  'appRoutes',\n  'controller'\n];\n\nconst AppRouter = Backbone.Router.extend({\n\n  constructor(options) {\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    Backbone.Router.apply(this, arguments);\n\n    const appRoutes = this.appRoutes;\n    const controller = this._getController();\n    this.processAppRoutes(controller, appRoutes);\n    this.on('route', this._processOnRoute, this);\n  },\n\n  // Similar to route method on a Backbone Router but\n  // method is called on the controller\n  appRoute(route, methodName) {\n    const controller = this._getController();\n    this._addAppRoute(controller, route, methodName);\n    return this;\n  },\n\n  // process the route event and trigger the onRoute\n  // method call, if it exists\n  _processOnRoute(routeName, routeArgs) {\n    // make sure an onRoute before trying to call it\n    if (_.isFunction(this.onRoute)) {\n      // find the path that matches the current route\n      const routePath = _.invert(this.appRoutes)[routeName];\n      this.onRoute(routeName, routePath, routeArgs);\n    }\n  },\n\n  // Internal method to process the `appRoutes` for the\n  // router, and turn them in to routes that trigger the\n  // specified method on the specified `controller`.\n  processAppRoutes(controller, appRoutes) {\n    if (!appRoutes) { return this; }\n\n    const routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes\n\n    _.each(routeNames, route => {\n      this._addAppRoute(controller, route, appRoutes[route]);\n    });\n\n    return this;\n  },\n\n  _getController() {\n    return this.controller;\n  },\n\n  _addAppRoute(controller, route, methodName) {\n    const method = controller[methodName];\n\n    if (!method) {\n      throw new Error(`Method \"${methodName}\" was not found on the controller`);\n    }\n\n    this.route(route, methodName, _.bind(method, controller));\n  }\n});\n\n_.extend(AppRouter.prototype, _.pick(MnObject.prototype, ObjectAPI));\n\n// For Backwards compatibility\nMarionette.AppRouter = AppRouter;\n\nexport default AppRouter;\n"]}